{"version":3,"sources":["serviceWorker.ts","store/reducers.ts","store/types.ts","store/index.ts","components/Button/Button.tsx","utils/getYouTubeVideoId.ts","components/Header/Header.tsx","store/actions.ts","utils/constants.ts","utils/loadYouTubeAPI.ts","components/Video/YouTube.tsx","utils/timeFormat.ts","components/Video/Video.tsx","components/Video/VideoList.tsx","components/MainContent/MainContent.tsx","components/App/App.tsx","index.tsx","utils/localStorage.ts"],"names":["Boolean","window","location","hostname","match","initialState","videos","playingVideo","reducerMap","state","youtubeId","payload","video","id","Math","max","map","volume","range","maxId","videoId","index","findIndex","length","splice","videoItem","previousVideoIndex","nextVideoIndex","rootReducer","action","type","reducerHandler","configureStore","middleware","composeWithDevTools","createStore","Button","className","color","onClick","children","buttonClass","getYouTubeVideoId","url","parsedUrl","replace","split","undefined","connector","connect","dispatch","onAddButtonClick","input","onPlayButtonClick","onStopButtonClick","onNextButtonClick","onPreviousButtonClick","useState","setInput","videosCount","isPlaying","canPlayPrevNext","href","placeholder","value","onChange","event","target","SITE_TITLE","api","getYouTubeAPI","win","Promise","resolve","YT","ready","tag","document","createElement","src","head","append","onYouTubeIframeAPIReady","loadYouTubeAPI","YouTube","onReady","onPlaying","onPaused","onEnded","onError","container","useRef","handleReady","player","handleError","useEffect","then","current","Player","events","onStateChange","data","stopVideo","handleStateChange","ref","timFormat","time","hours","floor","minutes","seconds","toString","padStart","removeVideo","editVideo","playVideo","playNextVideo","setPlayer","videoLoaded","setVideoLoaded","duration","setDuration","title","setTitle","playingStateChanged","setPlayingStateChanged","canMove","setVideoVolume","setVolume","trackStatus","currentTime","getCurrentTime","playerState","getPlayerState","getVolume","interval","setInterval","clearInterval","seekTo","scrollIntoView","behavior","block","pauseVideo","getDuration","getVideoData","vertical","Number","timeFormat","updateVideos","list","setList","handle","key","MainContent","App","serializedState","localStorage","getItem","JSON","parse","loadState","store","subscribe","throttle","stringify","setItem","saveState","getState","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.19d8d49d.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import {\n  Video,\n  State,\n  ActionType,\n  ReducerMap,\n  ADD_VIDEO_BY_YOUTUBE_ID,\n  ADD_VIDEO,\n  REMOVE_VIDEO,\n  EDIT_VIDEO,\n  UPDATE_VIDEOS,\n  PLAY_VIDEO,\n  PLAY_FIRST_VIDEO,\n  PLAY_PREVIOUS_VIDEO,\n  PLAY_NEXT_VIDEO,\n  ReducerHandler\n} from \"./types\";\n\nconst initialState: State = {\n  videos: [],\n  playingVideo: null\n}\n\nconst reducerMap: ReducerMap = {\n  [ADD_VIDEO_BY_YOUTUBE_ID]: (state, { payload: youtubeId }) => {\n    const maxId = Math.max(...state.videos.map(video => video.id), 0)\n    const video: Video = {\n      id: maxId + 1,\n      youtubeId,\n      volume: null,\n      range: [null, null]\n    }\n\n    return {\n      ...state,\n      videos: [...state.videos, video]\n    }\n  },\n\n  [ADD_VIDEO]: (state, { payload: video }) => {\n    const maxId = Math.max(...state.videos.map(video => video.id), 0)\n\n    return {\n      ...state,\n      videos: [...state.videos, { ...video, id: maxId + 1 }]\n    }\n  },\n\n  [REMOVE_VIDEO]: (state, { payload: videoId }) => {\n    const index = state.videos.findIndex(video => video.id === videoId)\n    let playingVideo: number | null = null\n\n    if (index !== null) {\n      if (state.playingVideo === videoId) {\n        if (state.videos.length <= 1) {\n          playingVideo = null\n        } else {\n          playingVideo = state.videos[index === state.videos.length - 1 ? 0 : index + 1].id\n        }\n      }\n\n      const videos = [...state.videos]\n      videos.splice(index, 1)\n\n      if (playingVideo !== null) {\n        return {\n          ...state,\n          videos,\n          playingVideo\n        }\n      } else {\n        return {\n          ...state,\n          videos\n        }\n      }\n    }\n\n    return state\n  },\n\n  [EDIT_VIDEO]: (state, { payload: video }) => {\n    const index = state.videos.findIndex(videoItem => videoItem.id === video.id)\n\n    if (index !== null) {\n      const videos = [...state.videos]\n      videos.splice(index, 1, video)\n\n      return {\n        ...state,\n        videos\n      }\n    }\n\n    return state\n  },\n\n  [UPDATE_VIDEOS]: (state, { payload: videos }) => {\n    return {\n      ...state,\n      videos\n    }\n  },\n\n  [PLAY_VIDEO]: (state, { payload: videoId }) => {\n    if (state.playingVideo !== videoId) {\n      return {\n        ...state,\n        playingVideo: videoId\n      }\n    }\n\n    return state\n  },\n\n  [PLAY_FIRST_VIDEO]: (state) => {\n    if (state.videos.length > 0) {\n      return {\n        ...state,\n        playingVideo: state.videos[0].id\n      }\n    }\n\n    return state\n  },\n\n  [PLAY_PREVIOUS_VIDEO]: (state) => {\n    if (state.videos.length > 0) {\n      let previousVideoIndex\n      const index = state.videos.findIndex(video => video.id === state.playingVideo)\n  \n      if (index === 0) {\n        previousVideoIndex = state.videos.length - 1\n      } else {\n        previousVideoIndex = index -1\n      }\n\n      return {\n        ...state,\n        playingVideo: state.videos[previousVideoIndex].id\n      }\n    }\n\n    return state\n  },\n\n  [PLAY_NEXT_VIDEO]: (state) => {\n    if (state.videos.length > 0) {\n      let nextVideoIndex\n      const index = state.videos.findIndex(video => video.id === state.playingVideo)\n\n      if (index === state.videos.length - 1) {\n        nextVideoIndex = 0\n      } else {\n        nextVideoIndex = index + 1\n      }\n\n      return {\n        ...state,\n        playingVideo: state.videos[nextVideoIndex].id\n      }\n    }\n\n    return state\n  }\n}\n\nexport const rootReducer = (state = initialState, action: ActionType): State => {\n  if (typeof reducerMap[action.type] === 'function') {\n    const reducerHandler = reducerMap[action.type] as ReducerHandler<typeof action.type>\n\n    return reducerHandler(state, action)\n  } else {\n    return state\n  }\n}\n\nexport type RootState = ReturnType<typeof rootReducer>\nexport default rootReducer","export interface Video {\n  id: number\n  youtubeId: string\n  volume: number | null\n  range: [number, number] | [null, null]\n}\n\nexport interface State {\n  videos: Video[]\n  playingVideo: number | null\n}\n\nexport const ADD_VIDEO_BY_YOUTUBE_ID = 'ADD_VIDEO_BY_YOUTUBE_ID'\nexport const ADD_VIDEO = 'ADD_VIDEO'\nexport const REMOVE_VIDEO = 'REMOVE_VIDEO'\nexport const EDIT_VIDEO = 'EDIT_VIDEO'\nexport const PLAY_VIDEO = 'PLAY_VIDEO'\nexport const PLAY_FIRST_VIDEO = 'PLAY_FIRST_VIDEO'\nexport const PLAY_NEXT_VIDEO = 'PLAY_NEXT_VIDEO'\nexport const PLAY_PREVIOUS_VIDEO = 'PLAY_PREVIOUS_VIDEO'\nexport const UPDATE_VIDEOS = 'UPDATE_VIDEOS'\n\ninterface addVideoByYouTubeIdAction {\n  type: typeof ADD_VIDEO_BY_YOUTUBE_ID\n  payload: string\n}\n\ninterface addVideoAction {\n  type: typeof ADD_VIDEO\n  payload: Video\n}\n\ninterface removeVideoAction {\n  type: typeof REMOVE_VIDEO\n  payload: number\n}\n\ninterface editVideoAction {\n  type: typeof EDIT_VIDEO\n  payload: Video\n}\n\ninterface updateVideosAction {\n  type: typeof UPDATE_VIDEOS\n  payload: Video[]\n}\n\ninterface playVideoAction {\n  type: typeof PLAY_VIDEO\n  payload: number\n}\n\ninterface playFirstVideoAction {\n  type: typeof PLAY_FIRST_VIDEO\n}\n\ninterface playPreviousVideoAction {\n  type: typeof PLAY_PREVIOUS_VIDEO\n}\n\ninterface playNextVideoAction {\n  type: typeof PLAY_NEXT_VIDEO\n}\n\ninterface stopVideoAction {\n  type: typeof PLAY_VIDEO\n  payload: null\n}\n\ntype ActionByType<T extends ActionType['type'], A = ActionType> = A extends {type: T} ? A : never\n\nexport type ActionType = addVideoByYouTubeIdAction | addVideoAction | removeVideoAction\n  | editVideoAction| updateVideosAction | playVideoAction | playFirstVideoAction\n  | playPreviousVideoAction | playNextVideoAction | stopVideoAction  \nexport type ReducerHandler<T extends ActionType['type']> = (state: State, action: ActionByType<T>) => State\nexport type ReducerMap = {\n  [T in ActionType['type']]?: ReducerHandler<T>\n}","import { Store, createStore } from 'redux'\nimport { composeWithDevTools } from 'redux-devtools-extension'\nimport { rootReducer, RootState } from './reducers'\n\nexport const configureStore = (initialState?: RootState): Store<RootState> => {\n  const middleware = composeWithDevTools()\n  const store = createStore(rootReducer, initialState, middleware) as Store<RootState>\n\n  return store\n}\n\nexport default configureStore","import React, { FunctionComponent } from 'react'\nimport './Button.scss'\n\ntype ButtonProps = {\n  className?: string,\n  color?: string\n  onClick?: () => void\n}\n\nexport const Button: FunctionComponent<ButtonProps> = ({ className = '', color, onClick, children }) => {\n  let buttonClass = className ? className + ' button' : 'button'\n\n  if (color) {\n    buttonClass += ` button--${color}`\n  }\n\n  return (\n    <button className={buttonClass} onClick={onClick}>\n      {children}\n    </button>\n  )\n}\n\nexport default Button","export const getYouTubeVideoId = (url: string): string => {\n  let videoId = ''\n  const parsedUrl = url.replace(/(>|<)/gi, '').split(/(vi\\/|v=|\\/v\\/|youtu\\.be\\/|\\/embed\\/)/)\n\n  if (parsedUrl[2] !== undefined) {\n    const parsedId = parsedUrl[2].split(/[^0-9a-z_-]/i)\n    videoId = parsedId[0]\n  } else {\n    videoId = url\n  }\n\n  return videoId\n}\n\nexport default getYouTubeVideoId","import React, { FunctionComponent, useState } from 'react'\nimport { connect, ConnectedProps } from 'react-redux'\nimport { State } from '../../store/types'\nimport Button from '../Button/Button'\nimport { addVideoByYouTubeId, stopVideo, playNextVideo, playPreviousVideo, playFirstVideo } from '../../store/actions'\nimport { Dispatch } from 'redux'\nimport './Header.scss'\n\nconst mapStateToProps = (state: State) => ({\n  videos: state.videos,\n  playingVideo: state.playingVideo\n})\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  onAddButtonClick: (input: string) => {\n    dispatch(addVideoByYouTubeId(input))\n  },\n  onPlayButtonClick: () => {\n    dispatch(playFirstVideo())\n  },\n  onStopButtonClick: () => {\n    dispatch(stopVideo())\n  },\n  onNextButtonClick: () => {\n    dispatch(playNextVideo())\n  },\n  onPreviousButtonClick: () => {\n    dispatch(playPreviousVideo())\n  }\n})\n\nconst connector = connect(mapStateToProps, mapDispatchToProps)\n\ntype PropsFromRedux = ConnectedProps<typeof connector>\ntype HeaderProps = PropsFromRedux\n\nexport const Header: FunctionComponent<HeaderProps> = ({ videos, playingVideo, onAddButtonClick, onPlayButtonClick, onStopButtonClick, onPreviousButtonClick, onNextButtonClick }) => {\n  const [input, setInput] = useState('')\n\n  const videosCount = videos.length\n  const isPlaying = playingVideo !== null\n  const canPlayPrevNext = isPlaying && videosCount > 1\n\n  return (\n    <header className=\"header\">\n      <div className=\"container\">\n        <a href=\"/\" className=\"header__logo\">YouTube Loop</a>\n\n        {videosCount > 0 &&\n          <div className=\"header__controls\">\n            {isPlaying?\n              <Button onClick={onStopButtonClick}>Stop</Button>\n              :\n              <Button onClick={onPlayButtonClick}>Play</Button>\n            }\n\n            {canPlayPrevNext &&\n              <>\n                <Button onClick={onPreviousButtonClick}>Previous</Button>\n                <Button onClick={onNextButtonClick}>Next</Button>\n              </>\n            }\n          </div>\n        }\n\n        <div className=\"header__input-group\">\n          <input type=\"text\" className=\"header__input\"\n            placeholder=\"Enter YouTube URL or Video ID\"\n            value={input}\n            onChange={event => setInput(event.target.value)}\n          />\n          <div className=\"header__input-group-append\">\n            <Button color=\"blue\" onClick={() => onAddButtonClick(input)}>Go Loop!</Button>\n          </div>\n        </div>\n      </div>\n    </header>\n  )\n}\n\nexport default connector(Header)\n","import {\n  Video,\n  ActionType,\n  ADD_VIDEO_BY_YOUTUBE_ID,\n  ADD_VIDEO, REMOVE_VIDEO,\n  EDIT_VIDEO,\n  UPDATE_VIDEOS,\n  PLAY_VIDEO,\n  PLAY_PREVIOUS_VIDEO,\n  PLAY_NEXT_VIDEO,\n  PLAY_FIRST_VIDEO\n} from './types'\nimport getYouTubeVideoId from '../utils/getYouTubeVideoId'\n\nexport const addVideoByYouTubeId = (youtubeId: string): ActionType => {\n  const youtubeVideoId = getYouTubeVideoId(youtubeId)\n\n  return {\n    type: ADD_VIDEO_BY_YOUTUBE_ID,\n    payload: youtubeVideoId\n  }\n}\n\nexport const addVideo = (video: Video): ActionType => {\n  return {\n    type: ADD_VIDEO,\n    payload: video\n  }\n}\n\nexport const removeVideo = (videoId: number): ActionType => {\n  return {\n    type: REMOVE_VIDEO,\n    payload: videoId\n  }\n}\n\nexport const editVideo = (video: Video): ActionType => {\n  return {\n    type: EDIT_VIDEO,\n    payload: video\n  }\n}\n\nexport const updateVideos = (videos: Video[]): ActionType => {\n  return {\n    type: UPDATE_VIDEOS,\n    payload: videos\n  }\n}\n\nexport const playVideo = (videoId: number): ActionType => {\n  return {\n    type: PLAY_VIDEO,\n    payload: videoId\n  }\n}\n\nexport const playFirstVideo = (): ActionType => {\n  return {\n    type: PLAY_FIRST_VIDEO\n  }\n}\n\nexport const playPreviousVideo = (): ActionType => {\n  return {\n    type: PLAY_PREVIOUS_VIDEO\n  }\n}\n\nexport const playNextVideo = (): ActionType => {\n  return {\n    type: PLAY_NEXT_VIDEO\n  }\n}\n\nexport const stopVideo = (): ActionType => {\n  return {\n    type: PLAY_VIDEO,\n    payload: null\n  }\n}\n","export const SITE_TITLE = 'YouTube Loop in TypeScript'\n\nexport const YOUTUBE_PLAYER_STATE_PLAYING = 1\nexport const YOUTUBE_PLAYER_STATE_PAUSED = 2\nexport const YOUTUBE_PLAYER_STATE_ENDED = 0","interface YTWindow extends Window {\n  YT: any\n  onYouTubeIframeAPIReady(): void\n}\n\nconst loadYouTubeAPI = () => {\n  const win = window as any as YTWindow\n\n  return new Promise<typeof win.YT>((resolve) => {\n    if (typeof win.YT === 'object' && typeof win.YT.ready === 'function') {\n      win.YT.ready(() => {\n        resolve(win.YT)\n      })\n\n      return\n    }\n\n    const tag = document.createElement('script')\n    tag.src = 'https://www.youtube.com/iframe_api'\n    document.head.append(tag)\n\n    if (!win.onYouTubeIframeAPIReady) {\n      win.onYouTubeIframeAPIReady = () => {\n        resolve(win.YT)\n      }\n    }\n  })\n}\n\nlet api: YTWindow['YT']  = null\n\nexport const getYouTubeAPI = () => {\n  if (!api) {\n    api = loadYouTubeAPI()\n  }\n\n  return api\n}\n\nexport default getYouTubeAPI","import React, { FunctionComponent, useRef, useEffect } from 'react'\nimport loadYouTubeAPI from '../../utils/loadYouTubeAPI'\nimport { YOUTUBE_PLAYER_STATE_PLAYING, YOUTUBE_PLAYER_STATE_PAUSED, YOUTUBE_PLAYER_STATE_ENDED } from '../../utils/constants'\n\ntype YouTubeProps = {\n  youtubeId: string\n  onReady?: (player: any) => void\n  onPlaying?: () => void\n  onPaused?: () => void\n  onEnded?: () => void\n  onError?: () => void\n}\n\nconst YouTube: FunctionComponent<YouTubeProps> = ({ youtubeId, onReady, onPlaying, onPaused, onEnded, onError }) => {\n  const container = useRef<HTMLDivElement>(null)\n\n  const handleReady = (player: any) => {\n    if (typeof onReady === 'function') {\n      onReady(player)\n    }\n  }\n\n  const handleError = () => {\n    if (typeof onError === 'function') {\n      onError()\n    }\n  }\n\n  const handleStateChange = (event: any, player: any) => {\n    if (event.data === YOUTUBE_PLAYER_STATE_PLAYING) {\n      if (typeof onPlaying === 'function') {\n        onPlaying()\n      }\n    } else if (event.data === YOUTUBE_PLAYER_STATE_PAUSED) {\n      if (typeof onPaused === 'function') {\n        onPaused()\n      }\n    } else if (event.data === YOUTUBE_PLAYER_STATE_ENDED) {\n      if (typeof onEnded === 'function') {\n        player.stopVideo()\n        onEnded()\n      }\n    }\n  }\n\n  useEffect(() => {\n    loadYouTubeAPI().then((YT: any) => {\n      if (container.current) {\n        const player = new YT.Player(container.current, {\n          videoId: youtubeId,\n          events: {\n            onReady: () => handleReady(player),\n            onError: handleError,\n            onStateChange: (event: any) => handleStateChange(event, player)\n          }\n        })\n      }\n    })\n  })\n\n  return (\n    <div ref={container}></div>\n  )\n}\n\nexport default YouTube\n","export const timFormat = (time: number): string => {\n  const hours = Math.floor(time / 3600)\n  const minutes = Math.floor((time - hours * 3600) / 60)\n  const seconds = time - hours * 3600 - minutes * 60\n\n  if (hours > 0) {\n    return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`\n  } else {\n    return `${minutes}:${seconds.toString().padStart(2, '0')}`\n  }\n}\n\nexport default timFormat","import React, { FunctionComponent, useState, useRef, useEffect } from 'react'\nimport { connect, ConnectedProps } from 'react-redux'\nimport { State, Video as TypeVideo } from '../../store/types'\nimport { Dispatch } from 'redux'\nimport { removeVideo, editVideo, playVideo, playNextVideo } from '../../store/actions'\nimport { SITE_TITLE, YOUTUBE_PLAYER_STATE_PLAYING } from '../../utils/constants'\nimport YouTube from './YouTube'\nimport Button from '../Button/Button'\nimport timeFormat from '../../utils/timeFormat'\nimport Slider, { Range } from 'rc-slider'\nimport 'rc-slider/assets/index.css'\nimport './Video.scss'\n\nconst mapStateToProps = (state: State) => ({\n  videos: state.videos,\n  playingVideo: state.playingVideo\n})\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  removeVideo: (videoId: number) => {\n    dispatch(removeVideo(videoId))\n  },\n  editVideo: (video: TypeVideo) => {\n    dispatch(editVideo(video))\n  },\n  playVideo: (videoId: number) => {\n    dispatch(playVideo(videoId))\n  },\n  playNextVideo: () => {\n    dispatch(playNextVideo())\n  }\n})\n\nconst connector = connect(mapStateToProps, mapDispatchToProps)\n\ntype PropsFromRedux = ConnectedProps<typeof connector>\ntype VideoProps = PropsFromRedux & {\n  video: TypeVideo\n}\n\nexport const Video: FunctionComponent<VideoProps> = ({ video, videos, playingVideo, removeVideo, editVideo, playVideo, playNextVideo }) => {\n  const [player, setPlayer] = useState<any>(null)\n  const [videoLoaded, setVideoLoaded] = useState(false)\n  const [duration, setDuration] = useState(0)\n  const [title, setTitle] = useState('')\n  const [playingStateChanged, setPlayingStateChanged] = useState(false)\n\n  const canMove = videos.length > 1\n  const isPlaying = playingVideo === video.id\n  const className = 'video' + (isPlaying ? ' video--active' : '')\n  const container = useRef<HTMLDivElement>(null)\n\n  const setVideoVolume = (volume: number) => {\n    if (player) {\n      player.setVolume(volume)\n    }\n\n    editVideo({\n      ...video,\n      volume\n    })\n  }\n\n  const setVideoRange = (range: [number, number]) => {\n    if (isPlaying && player) {\n      const currentTime = player.getCurrentTime()\n\n      if (typeof range[0] === 'number' && range[0] > currentTime) {\n        player.seekTo(range[0])\n      }\n    }\n\n    editVideo({\n      ...video,\n      range\n    })\n  }\n\n  const onVideoLoaded = (player: any) => {\n    const duration = player.getDuration()\n    setVideoLoaded(false)\n\n    if (!duration) {\n      removeVideo(video.id)\n    } else {\n      setPlayer(player)\n      setDuration(duration)\n      setTitle(player.getVideoData().title)\n\n      if (video.volume === null || video.range[0] === null || video.range[1] === null) {\n        editVideo({\n          ...video,\n          volume: player.getVolume(),\n          range: [0, duration]\n        })\n\n        if (isPlaying) {\n          player.setVolume(video.volume)\n          player.seekTo(video.range[0], true)\n          player.playVideo()\n\n          document.title = title + ' - ' + SITE_TITLE\n        }\n      }\n    }\n\n    setVideoLoaded(true)\n  }\n\n  const onPlaying = () => {\n    if (!isPlaying) {\n      playVideo(video.id)\n    }\n  }\n\n  const onEnded = () => {\n    playNextVideo()\n    setPlayingStateChanged(true)\n  }\n\n  const onError = () => {\n    removeVideo(video.id)\n  }\n\n  const trackStatus = () => {\n    if (player) {\n      const currentTime = player.getCurrentTime()\n      const playerState = player.getPlayerState()\n      const volume = player.getVolume()\n\n      if (volume !== video.volume) {\n        setVideoVolume(volume)\n      }\n\n      if (typeof video.range[1] === 'number' && playerState === YOUTUBE_PLAYER_STATE_PLAYING && currentTime > video.range[1]) {\n        onEnded()\n      }\n    }\n  }\n\n  useEffect(() => {\n    const interval = setInterval(trackStatus, 500)\n    \n    return () => clearInterval(interval)\n  })\n\n  useEffect(() => {\n    setPlayingStateChanged(true)\n\n    return () => setPlayingStateChanged(false)\n  }, [isPlaying])\n\n  useEffect(() => {\n    if (player && playingStateChanged) {\n      setPlayingStateChanged(false)\n\n      if (isPlaying) {\n        player.setVolume(video.volume)\n        player.seekTo(video.range[0], true)\n        player.playVideo()\n\n        document.title = title + ' - ' + SITE_TITLE\n        \n        if (container.current !== null) {\n          container.current.scrollIntoView({\n            behavior: 'smooth',\n            block: 'center'\n          })\n        }\n      } else {\n        player.pauseVideo()\n        document.title = SITE_TITLE\n      }\n    }\n  }, [player, isPlaying, title, playingStateChanged, video.volume, video.range])\n\n  return (\n    <div ref={container} className={className}>\n      <div className=\"video__player\">\n        <YouTube youtubeId={video.youtubeId} onReady={onVideoLoaded} onPlaying={onPlaying} onEnded={onEnded} onError={onError} />\n      </div>\n\n      {videoLoaded &&\n        <>\n          <Slider className=\"video__volume-slider\" vertical={true} value={Number(video.volume)} onChange={setVideoVolume} />\n          <Range className=\"video__range-slider\" max={duration} value={[Number(video.range[0]), Number(video.range[1])]} onChange={setVideoRange} />\n          <div className=\"video__info\">{`Volume: ${video.volume} — Range: ${timeFormat(Number(video.range[0]))} → ${timeFormat(Number(video.range[1]))}`}</div>\n        </>\n      }\n\n      <div className=\"video__buttons\">\n        {canMove &&\n          <Button className=\"video__move-handle\">Move</Button>\n        }\n        <Button color=\"red\" onClick={() => removeVideo(video.id)}>Remove Video</Button>\n      </div>\n    </div>\n  )\n}\n\nexport default connector(Video)\n","import React, { FunctionComponent } from 'react'\nimport { connect, ConnectedProps } from 'react-redux'\nimport { State, Video as TypeVideo } from '../../store/types'\nimport { Dispatch } from 'redux'\nimport { updateVideos } from '../../store/actions'\nimport { ReactSortable } from 'react-sortablejs'\nimport './VideoList.scss'\nimport Video from './Video'\n\nconst mapStateToProps = (state: State) => ({\n  videos: state.videos\n})\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  updateVideos: (videos: TypeVideo[]) => {\n    dispatch(updateVideos(videos))\n  }\n})\n\nconst connector = connect(mapStateToProps, mapDispatchToProps)\n\ntype PropsFromRedux = ConnectedProps<typeof connector>\ntype VideoListProps = PropsFromRedux\n\nexport const VideoList: FunctionComponent<VideoListProps> = ({ videos, updateVideos }) => {\n  if (!videos.length) {\n    return null\n  }\n\n  return (\n    <div>\n      <ReactSortable tag=\"ul\" list={videos} setList={updateVideos} handle=\".video__move-handle\" className=\"video-list\">\n        {videos.map(video => (\n          <li key={video.id} className=\"video-item\">\n            <Video video={video} />\n          </li>\n        ))}\n      </ReactSortable>\n    </div>\n  )\n}\n\nexport default connector(VideoList)\n","import React, { FunctionComponent } from 'react'\nimport VideoList from '../Video/VideoList'\n\nexport const MainContent: FunctionComponent = () => {\n  return (\n    <div className=\"main\">\n      <div className=\"container\">\n        <VideoList />\n      </div>\n    </div>\n  )\n}\n\nexport default MainContent\n","import React from 'react'\nimport Header from '../Header/Header'\nimport MainContent from '../MainContent/MainContent'\n\nexport const App = () => (\n  <>\n    <Header />\n    <MainContent />\n  </>\n)\n\nexport default App","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport * as serviceWorker from './serviceWorker';\nimport { Provider } from 'react-redux'\nimport configureStore from './store'\nimport App from './components/App/App'\nimport './sass/global.scss'\nimport { State } from './store/types';\nimport { loadState, saveState } from './utils/localStorage';\nimport throttle from 'lodash.throttle'\n\nconst state: State = loadState()\n\nconst initialState: State = {\n  videos: [],\n  playingVideo: null,\n  ...state\n}\n\nconst store = configureStore(initialState)\n\nstore.subscribe(throttle(() => {\n  saveState(store.getState())\n}, 1000))\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { State } from \"../store/types\"\n\nexport const loadState = () => {\n  try {\n    const serializedState = localStorage.getItem('state')\n\n    if (serializedState === null) {\n      return undefined\n    }\n\n    return JSON.parse(serializedState)\n  } catch {\n    return undefined\n  }\n}\n\nexport const saveState = (state: State) => {\n  try {\n    const serializedState = JSON.stringify(state)\n    localStorage.setItem('state', serializedState)\n  } catch {}\n}"],"sourceRoot":""}